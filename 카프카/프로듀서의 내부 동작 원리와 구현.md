[전체 목록](obsidian://open?vault=study&file=%EC%B9%B4%ED%94%84%EC%B9%B4%2F%EA%B3%B5%EB%B6%80%ED%95%A0%20%ED%82%A4%EC%9B%8C%EB%93%9C)
> 프로듀서의 기본 역할은 소스에 있는 <mark style="background: #D2B3FFA6;"><mark style="background: #FFB8EBA6;">메시지들을 카프카의 토픽으로 전송</mark></mark>하는 것

전송하려는 메시지는 Send 메서드를 통해서 시리 얼라이저, 파티셔너를 거쳐 카프카로 전송

# 파티셔너
---
## 파티셔너는 무엇? 

> 카프카는 토픽을 파티션으로 나누고, 최소 하나 또는 둘 이상의 파티션으로 나눈다. <mark style="background: #D2B3FFA6;">성능 향상을 위해 병렬 처리</mark>가 가능하기 위해서 파티션을 나눈다. 카프카로 전송한 메시지는 해당 토픽 내 가 파티션 로그 세그먼트에 저장된다. 따라서 이 떄 <mark style="background: #D2B3FFA6;">해당 토픽의 어느 파티션으로 메시지를 보내야 할지를  결정</mark>해야 하는데, 이때 사용하는 것이 바로 파티셔너(partitioner) 이다.

## 파티셔너의 파티션 결정 방식

> 기본적으로는 메시지(레코드)의 키를 해시처리해 파티션을 구하는 방식으로 사용한다. 따라서 메시지의 키의 해시값이 동일하면 해당 메시지들은 모두 같은 파티션으로 전송된다. 

> 파티션 수가 2 -> 4로 증가시켰을 때, 기존 파티션 1로 보내던 메시지가 파티션3으로 변경될 수 있다. 메시지 키를 이용해 카프카로 메시지 전송하는 경우 <mark style="background: #D2B3FFA6;">관리자 의도와 다른 방식으로 전송이 이뤄질 수 있기에 파티션 수를 변경하지 않는 것을 권장</mark>한다. 

![[Pasted image 20231029141923.png]]

## 파티션 결정 방식 - 라운드 로빈 전략

> 메시지 중 레코드의 키값은 필수값이 아니기에 관리자는 별도의 레코드 키값을 지정하지 않고 메시지를 전송할 수 있다. 키값을 지정하지 않고 키값은 null이 되며, 기본값은 로빈 알고리즘을 사용해 **<mark style="background: #D2B3FFA6;">프로듀서는 목적지 토픽의 파티션들로 레코드들을 랜덤 전송</mark>한다. 


![[Pasted image 20231029143223.png]]

> 위는 프로듀서의 내부 처리 과정을 보여주는 사진이다. 레코드 키값이 없으면 라운드 로빈으로 레코드가 파티션에 하나씩 할당된다. 이 메시지는 즉시 <mark style="background: #D2B3FFA6;">카프카로 전송되지 않은 채 전송을 위해 프로듀서의 버퍼 메모리에서 잠시 대기</mark>한다. 왜 대기하는가? 배치 전송을 위해서 최소 레코드 수를 지정해놨고, 3으로 지정되어있기 때문이다. 

> 프로듀서의 옵션을 조정해서 특정 시간을 초과하면 즉시 카프카로 레코드들을 전송하도록 설정할 수 있지만 이렇게하면 배치와 압축의 효과를 얻지 못한다. 레코드 하나만 전송되므로 매우 비효율적이다. 

파티셔너 카프카 내에서만 있는 줄 알았지만, 프로듀서 내에서도 파티션 있네... 
그리고 프로듀서 특정 시간 초과 옵션을 설정 안해서 영원히 레코드가 프로듀서에 남아있으면 문제가 되지 않는가?? 

## 파티션 결정 방식 - 스티키 파티셔닝 전략

> <mark style="background: #D2B3FFA6;">라운드 로빈 전략에서 지연시간이 불필요하게 증가되는 비효율적인 전송을 개선</mark>하고자 아파피 카프카 2.4 버전부터는 스티키 파티셔닝 전략을 사용하게 된다. 

> 스티키 파티셔닝이란 하나의 파티션에 레코드 수를 먼저 채워서 카프카로 빠르게 배치 전송하는 전략을 말한다. 


![[Pasted image 20231029144201.png]]

> 파티션 수는 3이고 배치를 위한 최소 레코드 수를 3이라고 설정하면, 위 그림과 가이 파티션 0을 다 채우고 다음 파티션에 레코드를 할당한다. 

>컨플루언트사에 따르면, 스티키 파티셔닝 전략을 적용함으 로써 기본 설정에 비해 약 30% 이상 지연시간이 감소하고 프로듀서의 CPU 사용률도 줄어 드는 효과를 얻을 수 있었다고 함. 카프카로 전송하는 <mark style="background: #D2B3FFA6;">메시지의 순서가 그다지 중요하지 않은 경우라면 스티키 파티셔닝 전략</mark>을 적용하기를 권장


# 프로듀서의 배치
---
>카프카에서는 토픽의 처리량을 높이기 위한 방법으로 토픽을 파티션으로 나눠 처리하며, 프로듀서에서는 처리량을 높이기 위해 배치 전송을 권장한다. 

![[Pasted image 20231029145339.png]]

### 배치 전송을 위한 옵션
- `buffer.memory`: 카프카로 메시지들을 담아두는 프로듀서의 버퍼 메모리 옵션이다. 기본값은 32MB이다. 조정 가능
- `batch.size`: 배치 전송을 위해 메시지들을 묶는 단위로 설정하는 <mark style="background: #D2B3FFA6;">배치 크기 옵션</mark>이다. 기본값은 16KB로 설정되어 있으며, 관리자는 배치 크기를 더 높이거나 줄 일 수 있습니다.
- `linger.ms`: 배치 전송을 위해 버퍼 메모리에서 대기하는 <mark style="background: #D2B3FFA6;">메시지들의 최대 대기 시간</mark>을 의미한다. 기본값 0(ms). 배치 전송을 위해 기다리지 않고 메시지들이 즉시 전송

### 배치 전송이 빠른 이유
> 단건의 메시지를 전송하는 것이 아니라 다량의 메시지를 묶어서 전송하기에 <mark style="background: #D2B3FFA6;">불필요한 I/O를 줄일 수</mark> 있어 매우 효율적이다. 더불어 <mark style="background: #D2B3FFA6;">카프카 요청 수 또한 줄여주는</mark> 효과가 있다. 


### 어떻게 설정하는게 좋을까? 
> <mark style="background: #D2B3FFA6;">처리량을 높이</mark>려면 batch.size와 linger.ms의 값을 크게 설정해야 하고, <mark style="background: #D2B3FFA6;">지연 없는 전송이 목표</mark>라면 batch.size와 linger.ms 의 값을 작게 설정해야 합니다.


### 구체적인 설정값에 대한 정답은 없다.
- 메시지 크기
- 초당 메시지 전송 수
- 네트워크 환경에 따른 전송 속도
를 고려해서 최적의 값을 찾아가는 것이 중요하다. 


### 높은 처리량이 목표라면
buffer.memory 크기는 반드시 batch.size보다 커야 합니다.

예를 들어 토픽 A가 3개의 파티션을 갖고 있고, batch.size는 기본값인 16KB이라고 가정한다면 buffer.memory의 최소 크기는 16KB * 3 = 48KB 이상이 되어야 한다. 


## 추가적인 효율적인 방법 - 압축
<mark style="background: #D2B3FFA6;">메시지들의 높은 압축률</mark><mark style="background: #D2B3FFA6;">을 선호</mark>한다면 gzip, zstd를 선택하는 것이 좋고, <mark style="background: #D2B3FFA6;">낮은 지연시간 을 선호</mark>한다면 lz4, snappy를 선택하기를 추천


# 중복 없는 전송
---
> 알림이나 주문과 같은 서비스에서 데이터가 중복으로 전송되면 기업의 입장에서 큰 문제가 된다. 카프카는 개발 편의를 높이기 위해 중복없이 전송할 수 있는 기능을 제공한다. (매우 어려운 작업이라고 한다.) 멱등성 전송..

메시지 시스템들의 메시지 전송 방식에는 
- 적어도 한 번 전송(at-least-once)
- 최대 한 번 한 번(at-most-once)
- 정확히 한 번 전송(exactly-once)
지금부터 적어도 한 번 전송과 최대 한 번 전송 방식은 서로 어떠한 차이가 있는지 알아보자


### 적어도 한 번 전송(at-least-once)

> 1. 프로듀서가 브로커의 특정 토픽으로 메시지A를 전송한다. 
> 2. 브로커는 메시지A를 기록하고, 잘 받았다는 ACK를 프로듀서에게 응답한다. 
> 3. 브로커의 ACK를 받은 프로듀서는 다음 메시지인 메시지B를 브로커에게 전송한다 
> 4. 브로커는 메시지B를 기록하고, 잘 받았다는 ACK를 프로듀서에게 전송하려고 합니 다. 하지만 <mark style="background: #D2B3FFA6;">네트워크 오류 또는 브로커 장애가 발생하여 결국 프로듀서는 메시지B에 대한 ACK를 받지 못합</mark>니다.
> 5. 메시지B를 전송한 후 브로커로부터 ACK를 받지 못한 <mark style="background: #D2B3FFA6;">프로듀서는 브로커가 메시지 B를 받지 못했다고 판단해 메시지B를 재전송</mark>합니다.

![[Pasted image 20231029154944.png|400]]

4번 과정에서 브로커가 프로듀서에게 ACK를 전달이 안 됐다. <mark style="background: #D2B3FFA6;">브로커가 메시지를 저장했는지 못했는지를 프로듀서 입장에서 알 수가 없다</mark>. 그렇기에 프로듀서는 <mark style="background: #D2B3FFA6;">적어도 한 번 전송 옵션</mark>이라면 무조건 다시 보내기 때문에 <mark style="background: #D2B3FFA6;">중복이 발생할</mark> 수 있다. 

카프카는 <mark style="background: #D2B3FFA6;">기본적으로 적어도 한 번 전송 방식을 기반으로 동작</mark>한다. 


### 최대 한 번 전송
---
> 1 ~ 2 : 정상 동작
> 3 : 프로듀서는 다음 메시지를 메시지B를 브로커에게 전송한다. 
> 4. 브로커는 메시지B를 기록하지 못하고, 잘 받았다는 <mark style="background: #D2B3FFA6;">ACK를 프로듀서에게 전송하지 못한</mark>다. 
> 5. <mark style="background: #D2B3FFA6;">프로듀서는 브로커가 메시지B를 받았다고 가정</mark>하고, 다음 메시지를 보낸다. 

![[Pasted image 20231029155517.png|400]]

최대 한 번 전송은 메시지 손실이 될 것이 다분하다. 어디에 쓰는게 좋을까? 

> 최대 한 번 전송을 이용하는 곳이 있을까 하는 생각이 들 수도 있겠지만, 일부 메시지가 손 실되더라도 높은 처리량을 필요로 하는 대량의 로그 수집이나 IoT 같은 환경에서 사용하곤 합니다.


### 중복 없는 전송

> 카프카 0.11버전에서는 프로듀서가 메시지를 중복 없이 브로커로 전송할 수 있는 기능이 추가됐다. 

> 1~5과정까지는 적어도 한 번 전송방식과 동일하다. 
> 5번 과정 이후 브로커 동작이 차이가 있다. 프로듀서가 재전송한 메시지B의 헤더에서 PID(0)와 메시지 번호(1)를 비교해서 메시지B가 이미 브로커에 저장되어 있는 것을 확인한 브로커느 메시지를 중복 저장하지 않고 ACK만 보낸다. 이런 브로커 동작으로 브로커에 저장된 메시지는 중복을 피할 수 있다. 
![[Pasted image 20231029160202.png|400]]


### 브로커 장애가 발생해도 중복 없는 메시지 전송이 가능한지? 

> PID는 사용자 생성하지 않고, 프로듀서에 의해 자동 생성된다. 이는 프로듀서와 카프카 사이에서 내부적으로만 이용되기에 사용자에게 노출되지 않는다. 또한 메시지마다 시퀀스 번호가 0번부터 순차적으로 증가한다. 

> 메시지마다 부여되는 시퀀스 번호는 0번부터 시작해 순차적으로 증가한다. 프로듀서에서 시퀀스 번호를 메시지마다 순차적으로 증가시키는 방법과 동일하게 브로커에서도 기록되는 메시지들에 대해 시퀀스 번호를 증가시킨다. 따라서 프로듀서가 보낸 메시지의 시퀀스 번호가 브로커가 갖고 있는 시퀀스 번호보다 정확하게 1 큰게 아니라면, 브로커는 프로듀셔의 메시지를 저장하지 않는다. 

> 메시지 중복을 피하기 위해 사용하는 PID와 시퀀스 번호 정보는 브로커의 메모리에 유지되고, 리플리케이션 로그에도 저장된다. 따라서 예기치 못하게 브로커 장애가 나더라도 새로운 리더가 PID와 시퀀스 번호를 정확히 알 수 있으므로 중복 없는 전송이 가능하다. 

### 정확히 한 번 전송의 탁월한 정확성으로 인해 오버헤드가 발생한다. 

>컨플루언트 블 로그 글(https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how- apache-kafka-does-it/)에 따르면, 중복 없는 전송을 적용한 후 기존 대비 최대 약 20% 정 도만 성능이 감소했다고 합니다. 메시지에 단순한 숫자 필드만 추가 하는 방법으로 구현했기에 이러한 오버헤드가 생각보다 높은 편은 아닙니다.

### 중복 없는 메시지 전송이 필요하다면
![[Pasted image 20231029162504.png]]


## 정확히 한 번 전송
---
카프카에서는 멱등성 옵션을 이용해 중복 없는 전송을 할 수 있다. 하지만 이 중복 없는 전송 방식이 정확히 한 번 전송한다는 의미는 아니다. (??)


> <mark style="background: #D2B3FFA6;">중복 없는 전송은 정확히 한 번 전송의 일부 기능이라고 한다.</mark> 전체적인 프로세스를 관리하기 위해 카프카에서는 <mark style="background: #D2B3FFA6;">정확히 한 번 처리를 담당하는 별도의 프 로세스가 있는데 이를 트랜잭션 API</mark>라고 부릅니다. 그럼 이제부터 카프카에서 정확히 한 번 전송 방식이 어떻게 구현되는지 살펴봅시다.


#### 트랜잭션 코디네이터(transaction coordinator)

> 프로듀서가 보내는 메시지들은 원자적으로 처리되어 전송에 성공하거나 실패하게 됩니다. 이런 프로듀서의 전송을 위해 커프카에는 컨슈머 그룹 코디네이터와 동일한 개념으로 트랙잰션 코디네이터라는 것이 서버 측에 존재한다. 

#### 정확히 하는 일이 뭐냐? 
> 프로듀서에 의해 전송된 메시지를 관리하며, 커밋  또는 중단 등을 표시한다. 

#### 어디에 표시하는데? 
> 카프카에서는 컨슈머 오프셋 관리를 위해 오프셋 정보를 카프카의 내부 토픽에 저장하는데, 트랜잭션도 동일하게 트랙잭션 로그를 카프카의 내부 토픽인 _transaction_state 에 저장한다. 

내부 토픽도 토픽이기 때문에 파티션 수와 리플리케이션 팩터 수가 존재한다. 브로커 설정을 통해 관리자가 설정할 수 있다. 

#### 정리해보자 
> 프로듀서가 해당 토픽에 트랜잭션 로그를 직접 기록하는 것이 아니다. 프로듀서는 트랜잭션 관련 정보를 트랙잰션 코디네이터에게 알리고 모든 정보의 로그는 트랜잭션 코디네이터가 직접 기록한다. 

#### 프로듀서는 커밋이 성공했는지 실패했는지 ACK에서 보내주는건가? 
> 카프카의 메시지를 다 루는 클라이언트들은 해당 메시지들이 정상적으로 커밋된 것인지 또는 실패한 것인지 식별 할 수 있어야 합니다. 카프카에서는 이를 식별하기 위한 정보로서, 컨트롤 메시지라고 불리 는 특별한 타입의 메시지가 추가로 사용됩니다.
> 
> 컨트롤 메시지는 페이로드에 애플리케이션 데이터(메시지의 밸류)를 포함하지 않으며, 애플 리케이션들에게 노출되지 않습니다. 컨트롤 메시지는 오직 브로커와 클라이언트 통신에서 만 사용됩니다.

정확히 이해되지 않네...


### 단계별 동작

정확히 한 번 전송을 위해서는 트랜잭션 API를 이용한다. 그래서 가장 먼저 수행하는 작업은 트랜잭션 코디네이터 찾기이다. 프로듀서는 브로커에게 FindCoordinator Request를 보내 트랜잭션 코디네이터의 위치를 찾는다. 이 트랜잭션 코디네이터는 브로커에 위치한다. 
![[Pasted image 20231029173459.png]]

트랜잭션 코디네이터는 <mark style="background: #D2B3FFA6;">PID(producerID)와 transactional.id를 매핑하고 해당 트랜잭션 전체를 관리</mark>하는 것이다. 만약 트랜잭션 코디네이터가 없다면 신규 트랜잭션 코디네이터가 생성한다. 


>__transaction_state 토픽의 파티션 번호는 transactional.id를 기반으로 해시하여 결정되 고, 이 파티션의 리더가 있는 브로커가 트랜잭션 코디네이터의 브로커로 최종 선정됩니다. 이는 transactional.id가 정확히 하나의 코디네이터만 갖고 있다는 의미와도 같습니다.

이해가 안되는걸...

프로듀서 초기화 동작