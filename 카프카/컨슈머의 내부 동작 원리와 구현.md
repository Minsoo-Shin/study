# 컨슈머 오프셋 관리

> 컨슈머 동작 중 가장 핵심은 오프셋 관리다. 컨슈머는 카프카에 저장된 메시지를 가져오는 역할을 하기 때문에 메시지를 어디까지 읽었는지에 대한 표시가 중요해진다. 예를 들어, 코드  배포로 인해 컨슈머가 일시적으로 동작을 멈추고 <mark style="background: #D2B3FFA6;">재시작하는 경우나, 컨슈머가 구동 중인 서버에서 문제가 발생해</mark> 새로운 컨슈머가 메시지를 가져올 수 있어야만 장애로부터 빠르게 복구가 가능하다. 

### 오프셋
> 메시지의 위치를 나타내는 위치를 오프셋이라고 부르는데, 이 오프셋은 숫자 형태로 나타낸다. 컨슈머 그룹은 자신의 오프셋 정보를 카프카에서 가장 안전한 저장소인 토픽에 저장한다. `__consumer_offsets` 토픽에 각 컨슈머 그룹별로 오프셋 위치 정보가 기록된다. 

![[Pasted image 20231105225004.png]]

- offsets.topic.replication.factor: 기본값 50
- offsets.topic.replication.factor: 기본값 3

# 그룹 코디네이터

> Coordination은 의상·화장·액세서리·구두 등을 전제적으로 균형 있고 조화롭게 갖추어 꾸미는 일이라고 한다. 정의 출처: [Oxford Languages](https://languages.oup.com/google-dictionary-ko)

## 그룹 코디네이터의 목적
---
이런 정의를 감안하여 그룹 코디네이터를 생각하면, 그룹 내 구성원들을 전체적으로 균형 있고, 조화롭게 하는 관리자 같은 느낌이다. 그렇다면 균형있고, 조화를 이룬다는 것은 무엇일까?

> 컨슈머들은 하나의 컨슈머 그룹의 구성원으로 속하며, 그룹내의 각 컨슈머들은 서로 자신의 정보를 공유하면서 하나의 공동체로 동작한다. 그룹 내의 컨슈머들은 언제든지 <mark style="background: #D2B3FFA6;">자신이 속한 컨슈머 그룹에서 떠나고 합류</mark>할 수 있다. 이 때, <mark style="background: #D2B3FFA6;">컨슈머 그룹은 이러한 변화를 인지하고</mark> <mark style="background: #D2B3FFA6;">각 컨슈머들에게 작업을 균등하게 분배</mark>한다. 컨슈머 그룹에서 각 컨슈머들에게 작업을 균등하게 분해하는 동작을 <mark style="background: #D2B3FFA6;">컨슈머 리밸런싱</mark>이라고 표현한다. 

## 그룹 코디네이터는 어디에 위치하는가? 
---
그룹 코디네이터의 목적은 컨슈머들을 상태를 트래킹하여 적절하게 분배하는데 있다. 그 코디네이터는 어디에 위치하는 것일까? 카프카 클러스터 내의 브로커 중 하나에 위치한다. 
![[Pasted image 20231105233240.png]]

## 그룹 코디네이터의 동작
--- 
1. `bootstrap_servers`에 있는 브로커에게 컨슈머 클라이언트와 초기 커넥션을 연결하기 위한 요청을 보내다. 
2. 해당 요청을 받은 브로커는 그룹 코디네이터를 생성하고 컨슈머에게 응답을 보낸다. 컨슈머 그룹의 첫 번째 컨슈머가 등록될 때까지 아무 작업도 일어나지 않는다. 
3. 그룹 코디네이터는 `group.initial.rebalance.delay.ms`의 시간 동안 컨슈머의 요청을 기다린다. 
	 - 어느 정도 값이 필요한지?? 건드려야하는건지? 
 
4. 컨슈머는 컨슈머 등록 요청을 그룹 코디네이터에게 보냅니다. 이때 가장 먼저 요청을 보내는 컨슈머가 <mark style="background: #D2B3FFA6;">리더</mark>가 된다. 
5. 컨슈머 등록 요청받은 그룹 코디네이터는 해당 컨슈머 그룹이 구독하는 토픽 파티션 리스트 등 리더 컨슈머의 요청에 응답을 보낸다. 
6. 리더 컨슈머는 정해진 컨슈머 파티션 할당 전략에 따라 그룹 내 컨슈머들에게 파티션을 할당한 뒤 그룹 코디네이터에게 전달한다. 
	- 리더는 5번에서 토픽 파티션 리스트를 그룹 코디네이터에 받아서 할당 전략에 따라 그룹 내 컨슏머들에게 할당한다. 

7. 그룹 코디네이터는 해당 정보를 캐시하고 각 그룹 내 컨슈머들에게 성공을 알린다. 
8. 각 컨슈머들은 각자 지정된 토픽 파티션으로부터 메시지들을 가져온다.

![[Pasted image 20231105233507.png]]

코드로는 bootstrap.brokers, group.id만 설정하면 컨슈머 그룹이 생성되어 카프카로부터 구독한 메시지를 읽어온다. 이제 컨슈머 그룹에서 빠져나갈 수도, 새롭게 합류할 수도 있다. 이러한 컨슈머 그룹의 변화들은 컨슈머들이 그룹 코디네이터에게 컨슈머가 join또는 leave 요청을 보냄으로써 자연스럽게 처리된다. 

하지만, 컨슈머가 장애로 leave 요청을 보내지 못하고 종료되는 경우는 어떻게 감지할 수 있을까? 
> 컨슈머들은 변경을 감지하기 위해 그룹 코디네이터와 컨슈머들은 서로 하트비트를 주고 받는다. 하트 비트 관련  옵션은 다음 세가지가 있다. 

![[Pasted image 20231106001022.png]]

이렇게 세가지 옵션으로 컨슈머의 상태를 확인할 수 있다. heartbeat로 단순하게 상태를 확인할 수도 있고, 실제로 poll() 동작 여부를 통해 확인하는 등 카프카의 세심하고 상세한 설정할 수 있다. 

>관리자는 표 6-1의 옵션값들을 조금씩 변경해 컨슈머 다운을 더 빠르게 혹은 더 느리게 감지하도록 조정할 수도 있습니다. 하지만 옵션값들 의 시간을 일부 변경해 그룹 코디네이터가 컨슈머의 다운을 빠르게 감지하도록 설정해둔다 면, 일시적인 컨슈머의 타임아웃이나 일시적인 TCP 패킷 손실로 인해 원하지 않은 리밸런싱이 빈번하게 일어나는 현상이 발생할 수도 있습니다. 
> 반대로 그룹 코디네이터가 컨슈머 다운을 늦게 감지하도록 설정해두면, 그 시간만큼 해당 파티션의 메시지를 읽지 못하는 현상 이 발생할 수도 있습니다. 이렇게 시간값 조정에 따른 장단점이 존재하므로, 가능하면 기본 설정을 유지하기를 권장하며 반드시 필요한 경우에만 관련 옵션값을 변경하기 바랍니다.

# 스태틱 멤버십  
# 컨슈머 파티션 할당 전략 정확히 한 번 컨슈머 동작